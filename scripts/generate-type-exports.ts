#!/usr/bin/env bun
import { existsSync, readFileSync, writeFileSync } from 'node:fs';
import { join } from 'node:path';

const SERVICES = ['radarr', 'sonarr', 'lidarr', 'readarr', 'prowlarr'] as const;

type Service = (typeof SERVICES)[number];

/**
 * Extract all exported type names from a TypeScript file
 */
function extractExportedTypes(filePath: string): string[] {
  if (!existsSync(filePath)) {
    console.warn(`‚ö†Ô∏è  File not found: ${filePath}`);
    return [];
  }

  const content = readFileSync(filePath, 'utf-8');
  const exportTypeRegex = /^export\s+type\s+(\w+)/gm;
  const types: string[] = [];

  let match: RegExpExecArray | null = exportTypeRegex.exec(content);
  while (match !== null) {
    types.push(match[1]);
    match = exportTypeRegex.exec(content);
  }

  return types.sort();
}

/**
 * Generate type export file content for a service
 */
function generateTypeExportContent(service: Service, types: string[]): string {
  const serviceName = service.charAt(0).toUpperCase() + service.slice(1);

  return `// Auto-generated type exports for ${serviceName}
// This file is automatically generated by scripts/generate-type-exports.ts
// Do not edit manually - changes will be overwritten

export type {
${types.map(type => `  ${type},`).join('\n')}
} from '../generated/${service}/types.gen.js';
`;
}

/**
 * Update client file to re-export types
 */
function updateClientFile(service: Service) {
  const clientFile = join(process.cwd(), `src/clients/${service}.ts`);

  if (!existsSync(clientFile)) {
    console.warn(`‚ö†Ô∏è  Client file not found: ${clientFile}`);
    return;
  }

  let content = readFileSync(clientFile, 'utf-8');

  // Check if re-export line already exists
  const reExportPattern = new RegExp(`export \\* from '\\.\\/${service}-types\\.js';`);

  if (!reExportPattern.test(content)) {
    // Add re-export at the end if it doesn't exist
    if (!content.endsWith('\n')) {
      content += '\n';
    }
    content += `\n// Re-export types for external consumption\nexport * from './${service}-types.js';\n`;

    writeFileSync(clientFile, content);
    console.log(`‚úÖ Updated ${service} client to re-export types`);
  }
}

/**
 * Main function to generate all type exports
 */
function generateAllTypeExports() {
  console.log('üîß Generating automated type exports...\n');

  for (const service of SERVICES) {
    console.log(`üì° Processing ${service}...`);

    // Extract types from generated types file
    const typesFile = join(process.cwd(), `src/generated/${service}/types.gen.ts`);
    const exportedTypes = extractExportedTypes(typesFile);

    if (exportedTypes.length === 0) {
      console.warn(`‚ö†Ô∏è  No types found for ${service}, skipping...`);
      continue;
    }

    // Generate type export file
    const typeExportContent = generateTypeExportContent(service, exportedTypes);
    const outputFile = join(process.cwd(), `src/clients/${service}-types.ts`);

    writeFileSync(outputFile, typeExportContent);
    console.log(`  ‚úÖ Generated ${outputFile} with ${exportedTypes.length} types`);

    // Update client file to re-export types
    updateClientFile(service);
  }

  console.log('\nüéâ Type export generation complete!');
  console.log('\nGenerated exports include:');

  for (const service of SERVICES) {
    const typesFile = join(process.cwd(), `src/generated/${service}/types.gen.ts`);
    const typeCount = extractExportedTypes(typesFile).length;
    console.log(`  ‚Ä¢ ${service}: ${typeCount} types`);
  }

  console.log('\nüí° Usage example:');
  console.log(`import type { RootFolderResource, IndexerResource } from 'tsarr/sonarr/types'`);
}

// Run if called directly
if (import.meta.main) {
  try {
    generateAllTypeExports();
  } catch (error) {
    console.error('‚ùå Error generating type exports:', error);
    process.exit(1);
  }
}
